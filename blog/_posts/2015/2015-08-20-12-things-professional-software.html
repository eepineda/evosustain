---

title: 12 things professional software developers do
date: '2015-08-20T15:42:00.000+02:00'

tags: 
modified_time: '2015-08-20T15:49:50.438+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-6405854463754891589
blogger_orig_url: http://www.continuousimprover.com/2015/08/12-things-professional-software.html
---

<span style="font-family: inherit;">Quite recently me and a coworker had a lively discussion on what constitutes a great software developer, or, in more blunt terms, what separates the professional from the amateur. This got me thinking about the things I currently think are crucial in any professional software developer. Here’s my opinion on this.</span><br /><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They optimize their code for readability</span></span></div><div style="margin: 0in;"><span style="font-family: inherit;">If you're designing a system in which data is read much more often than it is written, wouldn't you optimize the system for reading? So assuming you would, if you know that source code is read many more times than it is written, shouldn't you optimize your source code for readability? </span><a href="http://www.csharpcodingguidelines.com/"><span style="font-family: inherit;">Coding guidelines</span></a><span style="font-family: inherit;">, </span><a href="http://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882"><span style="font-family: inherit;">Clean Code</span></a><span style="font-family: inherit;"> and </span><a href="http://www.slideshare.net/dennisdoomen/object-calisthenetics"><span style="font-family: inherit;">Object Calisthenics</span></a><span style="font-family: inherit;"> are all practices that exist because other smart developers are trying to do just that: optimize for readability. </span></div><br /><div style="margin: 0in;"><span style="font-family: inherit;">And BTW, I don't care if you can read your own obscure or functional code well. It's not you will have to maintain that code for the foreseeable future. Instead, optimize it so that your (future) co-workers understand what you were trying to do.</span><span style="mso-spacerun: yes;"><span style="font-family: inherit;">&nbsp; </span></span><span style="font-family: inherit;">And don't give me that excuse that those people are not smart enough to understand your code. Unless you're trying to make yourself un-expendable without your boss knowing about that, drop the arrogance and do what it takes to be a professional.</span></div><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They document their classes and members</span></span></div><span style="font-family: inherit;">Triggered by this </span><a href="http://blog.codefx.org/techniques/documentation/comment-your-fucking-code/"><span style="font-family: inherit;">excellent article</span></a><span style="font-family: inherit;"> by </span><a href="https://twitter.com/nipafx"><span style="font-family: inherit;">Nicolai Parlog</span></a><span style="font-family: inherit;">, the most annoying thing that can happen if you're using somebody else's API is that you have to dive into its implementation to understand how that API is supposed to behave. So properly document the expected behavior of all your public and protected classes and members. Don't repeat the name of the class or member but explain why it exists, what problem it is supposed to solve and what the boundaries of its responsibilities are. If a class has a strong relationship with another, document how these two work together.</span><br /><br /><div style="margin: 0in;"><span style="font-family: inherit;">By the way, I'm not talking about commenting lines of code here. Nine out of ten, if you find the need to comment code, it's probably because your methods don't have the </span><a href="https://github.com/dennisdoomen/csharpguidelines/blob/master/Guidelines/1500_MaintainabilityGuidelines.md#methods-should-not-exceed-7-statements-av1500-"><span style="font-family: inherit;">right granularity</span></a><span style="font-family: inherit;">. The only exception where I personally use inline comments is if I'm using a specific algorithm that is difficult to deduce from the code, or if some </span><a href="https://github.com/dennisdoomen/csharpguidelines/blob/master/Guidelines/1500_MaintainabilityGuidelines.md#methods-should-not-exceed-7-statements-av1500-"><span style="font-family: inherit;">special circumstance</span></a><span style="font-family: inherit;"> applies that the reader needs to understand.</span></div><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They leave the campground cleaner than they entered it</span></span></div><span style="font-family: inherit;">The quality of software can only go two ways. It can improve or it can rot. The easiest way to improve your code base is to make sure each and every change you do improves it. Whether it is the length of a method, the refinement of a method name or by improving the API documentation, it doesn't matter. As long as it improves the quality a notch or two. If you're already practicing </span><a href="http://www.slideshare.net/dennisdoomen/tdd-and-solid-two-ingredients-for-high-quality-software"><span style="font-family: inherit;">Test Driven Development</span></a><span style="font-family: inherit;">, then </span><a href="http://www.continuousimprover.com/2015/02/continuous-refactoring-in-its-natural.html"><span style="font-family: inherit;">continuously refactoring</span></a><span style="font-family: inherit;"> your code is already part of your mantra. If you're fixing a bug, make sure you first add a unit test to proof the bug. If that's difficult to do, make it easier by refactoring the code so to improve testability. And if you don't have to time right now to fix a design smell or apply a potential refactoring, consider using the </span><a href="http://www.infoq.com/articles/natural-course-refactoring"><span style="font-family: inherit;">Natural Refactoring</span></a><span style="font-family: inherit;"> workflow to mark code as such.</span><br /><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They maintain a clean source control history</span></span></div><span style="font-family: inherit;">A clean source control history is one that has the following characteristics:</span><br /><ul style="direction: ltr; margin-bottom: 0in; margin-left: .375in; margin-top: 0in; unicode-bidi: embed;" type="disc"><li style="margin-bottom: 0; margin-top: 0; vertical-align: middle;"><span style="font-family: inherit;">Changes are grouped in </span><span style="font-style: italic;"><span style="font-family: inherit;">commits</span></span><span style="font-family: inherit;"> (in Git) of related changes      where large-scale renames or file movements are grouped in a separate      commits.</span></li><li style="margin-bottom: 0; margin-top: 0; vertical-align: middle;"><span style="font-family: inherit;">Irrelevant changes such as      commits with a message like 'Oops, I've fixed a unit tests' or 'Processed      review comments' should not exist.</span></li><li style="margin-bottom: 0; margin-top: 0; vertical-align: middle;"><span style="font-family: inherit;">The commit should clearly      explain why something was changed. The </span><span style="font-style: italic;"><span style="font-family: inherit;">what </span></span><span style="font-family: inherit;">should be visible from the      code changes</span><span style="mso-spacerun: yes;"><span style="font-family: inherit;">&nbsp; </span></span><span style="font-family: inherit;">themselves.</span></li></ul><div style="margin: 0in;"><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">Such a clean history not only benefits those that want to understand why something was changed during a historically analysis, but should also make it much easier for other people to branch and merge from. Especially those that use Git's </span><a href="https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase/"><span style="font-family: inherit;">rebase</span></a><span style="font-family: inherit;">feature will be very sad if they have to resolve conflicts with a messy code base. So, if you're using Git (</span><a href="http://www.continuousimprover.com/2015/06/why-you-should-abandon-tfs-source.html"><span style="font-family: inherit;">and you should</span></a><span style="font-family: inherit;">), learn how to use its powerful features such as </span><a href="http://blogs.atlassian.com/2014/06/interactive-rebase-sourcetree/"><span style="font-family: inherit;">interactive rebases</span></a><span style="font-family: inherit;">, squashing, </span><a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git"><span style="font-family: inherit;">fixing up commits</span></a><span style="font-family: inherit;"> and such.</span><span style="mso-spacerun: yes;"><span style="font-family: inherit;">&nbsp; </span></span></div><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They understand their domain</span></span></div><div style="margin: 0in;"><span style="font-family: inherit;">Understand what you're building from an end-user perspective. What problem is the system going to solve for them. What will make a real difference here? What are the current pain points you're trying to solve? Are different people using different terms for the same concept? Or are they using the same term for different concepts that warrants different </span><a href="http://martinfowler.com/bliki/BoundedContext.html"><span style="font-family: inherit;">Bounded Contexts</span></a><span style="font-family: inherit;">. Does the domain have a </span><a href="http://www.continuousimprover.com/2010/08/alm-practices-part-9-ubiquitous.html"><span style="font-family: inherit;">Ubiquitous Language</span></a><span style="font-family: inherit;">? If not, get the stakeholders to introduce one and adhere your code to it. If the names of concepts change, change your code. Do you have a domain at all? If not, consider using techniques like </span><a href="http://ziobrando.blogspot.com/2013/11/introducing-event-storming.html#.VdMofuEVhhs"><span style="font-family: inherit;">Event Storming</span></a><span style="font-family: inherit;"> to extract the domain from non-technical stakeholders. </span></div><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They know the sub-system boundaries</span></span></div><span style="font-family: inherit;">Each component, sub-system or product can have their own level of adherence of the stuff mentioned before. Some need less (spikes, temporary components, proofs-of-concepts), some need more. Boundaries should define interactions and contracts and can help prevent ending up with monolithic code bases. Consider using an </span><a href="http://www.markhneedham.com/blog/2009/07/07/domain-driven-design-anti-corruption-layer/"><span style="font-family: inherit;">anti-corruption layer</span></a><span style="font-family: inherit;"> to protect those boundaries. Each boundary can (should) have their own Ubiquitous Language, so the same term can mean different concepts between two boundaries. Boundaries can also help preventing monoliths, so identifying boundaries is an essential principle that should not be underestimated. It doesn't happen magically, but modern tooling like those facilitated by Git, Github and NuGet can help set-up your organization to </span><a href="http://www.continuousimprover.com/2015/03/a-scalable-software-development.html"><span style="font-family: inherit;">acknowledge boundaries as a first-class citizen</span></a><span style="font-family: inherit;">.</span><br /><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They are aware of the trade-offs</span></span></div><span style="font-family: inherit;">Even though our clients might think they need it, we're not all building Formula 1 cars. So don't jeopardize maintainability by tuning, tweaking and optimizing your code until it performs at top speed but becomes utterly unreadable. That doesn't excuse you from using the wrong data structures, algorithms and common sense though. Don't use a List for an index if you can also use an Dictionary. In the unlikely case that you really need to build the software equivalent of a Formula 1 car that can only be maintained by the best, consider extracting the critical components into separate source control repositories </span><a href="https://git-scm.com/book/it/v2/Distributed-Git-Distributed-Workflows"><span style="font-family: inherit;">owned</span></a><span style="font-family: inherit;">by those special people. Again, control your boundaries.</span><br /><span style="font-family: inherit; font-weight: bold;"><br /></span><span style="font-family: inherit; font-weight: bold;">They consider the reversibility of their decisions</span><br /><span style="font-family: inherit;">Not every decision has to be made right now. Always consider the cost of postponing a decision to its </span><a href="http://codebetter.com/jeremymiller/2006/01/18/leaky-abstractions-and-the-last-responsible-moment-for-design/"><span style="font-family: inherit;">last responsible moment</span></a><span style="font-family: inherit;">. If it doesn't matter whether you do it later rather than now, do it later. Following </span><a href="http://martinfowler.com/bliki/Yagni.html"><span style="font-family: inherit;">YAGNI properly</span></a><span style="font-family: inherit;"> can really help you in this decision process and prevent analysis paralysis. I've seen too many senior developers getting all warm and fuzzy while building the ultimate future-proof solution and completely forgetting that they are working for a firm that at the end of the day needs to make money. I'm not saying that you should postpone all decisions here. I'm just saying that you should understand </span><a href="http://www.continuousimprover.com/2015/03/what-kind-of-software-architect-are-you.html"><span style="font-family: inherit;">when you should think tactically and when strategically</span></a><span style="font-family: inherit;">.</span><br /><div style="margin: 0in 0in 0in 0.375in;"><br /></div><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They fight fear of change</span></span></div><span style="font-family: inherit;">As soon as somebody doesn't feel confident about changing some code because they </span><a href="https://medium.com/javascript-scene/how-to-build-a-high-velocity-development-team-4b2360d34021"><span style="font-family: inherit;">fear</span></a><span style="font-family: inherit;">side-effects, you're lost. If you</span><span style="mso-spacerun: yes;"><span style="font-family: inherit;">&nbsp; </span></span><span style="font-family: inherit;">detect that kind of fear, immediately analyze the reasons behind it. Is it insufficient unit test coverage? Then try to add the missing part or consider writing a couple of characteristics tests. Is it the lack of user interface testing? Invest in UI testing using </span><a href="http://www.seleniumhq.org/"><span style="font-family: inherit;">Selenium</span></a><span style="font-family: inherit;">and </span><a href="https://www.browserstack.com/"><span style="font-family: inherit;">BrowserStack</span></a><span style="font-family: inherit;"> (and read </span><a href="http://jeremydmiller.com/2015/06/25/succeeding_with_integration_testing/"><span style="font-family: inherit;">this post</span></a><span style="font-family: inherit;"> first). Is it because the deployment involves lots of moving parts? Consider </span><a href="http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin_21.html"><span style="font-family: inherit;">introducing OWIN</span></a><span style="font-family: inherit;"> to easily host all your components in an unit test. Is it an occasionally failing unit test? And warning in a log file that should not really happen? Just analyze the problem and fix it! The worst thing you can do is ignore these kind of problems because of project pressure. The longer you wait, they'll get more painful and definitely more expensive to fix.</span><br /><br /><div style="margin: 0in;"><span style="font-family: inherit; font-weight: bold;">They will continuously shorten the feedback loop</span></div><span style="font-family: inherit;">One aspect of avoiding fear of change is to make sure the feedback loop between making a change and getting confirmation that your changes have not caused any side-effects as short as possible. If your unit tests are taking too much time to complete, consider switching to </span><a href="http://xunit.github.io/"><span style="font-family: inherit;">XUnit</span></a><span style="font-family: inherit;">to benefit from its </span><a href="http://xunit.github.io/docs/running-tests-in-parallel.html"><span style="font-family: inherit;">concurrent execution</span></a><span style="font-family: inherit;">. If they are just too slow, use a </span><a href="https://www.jetbrains.com/profiler/"><span style="font-family: inherit;">profiler</span></a><span style="font-family: inherit;"> to find the bottlenecks. Overusing IoC containers and mocking frameworks was a big issue for us. Ideally you'll find some product issues that will benefit the end-users along the way. If your build process is pretty extensive, consider using something like </span><a href="https://confluence.jetbrains.com/display/TCD8/Build+Chain"><span style="font-family: inherit;">build chaining</span></a><span style="font-family: inherit;">and </span><a href="https://confluence.jetbrains.com/display/TCD8/Dependent+Build#DependentBuild-ArtifactDependency"><span style="font-family: inherit;">artifact dependencies</span></a><span style="font-family: inherit;"> (provided your build engine supports that). Is NuGet to slow for you? Consider using an (on-premise) </span><a href="http://myget.org/"><span style="font-family: inherit;">MyGet</span></a><span style="font-family: inherit;">cache. Is your Git repository too big? Consider </span><a href="http://jedidjah.ch/code/2014/8/28/purge_old_git_history/"><span style="font-family: inherit;">purging</span></a><span style="font-family: inherit;"> a part of its history. Obviously these are just examples. The point is that you should make an effort to solve these problems as soon as possible, and if possible, account for this in your architecture design.</span><br /><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They will seek feedback and embrace criticism</span></span></div>A quality I don't see that often in developers is the ability to second guess their own ideas. I lost count of how many times an idea of mine got either bunked because it was way too naïve, or got much better with the input of my team members. If you're so unfortunate to not have anybody around you to challenge your ideas, visit local user groups, events or conferences. They are great for sparring with peers or gaining new ideas and concepts, especially if they offer Open Spaces or Chalk-and-Talk sessions. Blogging about your ideas is similar to asking for feedback, especially if you support Disquss or you're on Twiter. Presenting about your ideas is the next level, something I occasionally do. Some people are too afraid to go on-stage, but I get a lot of confidence from the fact that I'm presenting my own experiences. I might be wrong about something, but in the worst possible case you learn something new from it.<br /><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">They know how to fill the knowledge gap</span></span></div><span style="font-family: inherit;">I see myself as an all-round professional with a wide range of skills covering .NET, architecture styles, design patterns, agile development, application lifecycle management with a strong focus on building maintainable software. I'm nowhere an expert in any of those fields, but I do know who to talk to if I really need in-depth knowledge and experience on a certain topic. Twitter, StackOverflow and </span><a href="https://gitter.im/"><span style="font-family: inherit;">Gitter</span></a><span style="font-family: inherit;"> are my friends here and will never let me down.</span><br /><br /><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">So what do you think?</span></span></div><div style="margin: 0in;"><span style="font-family: inherit;">So what do you think? Does this resonate with your opinions of a professional software developer? Did I miss anything? Do you object with anything I said? Let me know by commenting below. And follow me at </span><a href="https://twitter.com/ddoomen"><span style="font-family: inherit;">@ddoomen</span></a><span style="font-family: inherit;">to get regular updates on my everlasting quest for better solutions. </span></div><b></b><i></i><u></u><sub></sub><sup></sup><strike></strike><span style="font-family: inherit;"></span>